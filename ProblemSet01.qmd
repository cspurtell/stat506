---
title: "Purtell_ProblemSet01"
author: "Colin Purtell"
format:
  html: 
    embed-resources: true
    standalone: true
editor: visual
---

## STATS 506 Problem Set 1:

### Problem 1

#### a.

```{r}
abalones <- read.csv("data/abalone.data")
colnames(abalones) <- c("Sex", 
                        "Length", 
                        "Diameter", 
                        "Height", 
                        "Whole.weight",
                        "Shucked.weight",
                        "Viscera.weight",
                        "Shell.weight",
                        "Rings")
```

#### b.

```{r}
table(abalones$Sex)
```

According to the table, there are 1307 female abalones, 1342 infants, and 1527 males.

#### c. 

```{r}
weights <- abalones[, c("Whole.weight", "Shucked.weight", "Viscera.weight", 
                        "Shell.weight", "Rings")]
cor(weights)
```

It appears that shell weight has the highest correlation with number of rings.

```{r}
abs_m <- subset(abalones, Sex == "M")
abs_f <- subset(abalones, Sex == "F")
abs_i <- subset(abalones, Sex == "I")
cor(abs_m$Shell.weight, abs_m$Rings)
cor(abs_f$Shell.weight, abs_f$Rings)
cor(abs_i$Shell.weight, abs_i$Rings)
```

When looking only at shell weight, it appears that the infant designation has the highest correlation with number of rings.

```{r}
oldest <- subset(abalones, Rings == max(abalones$Rings))
oldest[, c("Whole.weight", "Shucked.weight", "Viscera.weight", "Shell.weight")]
```

The abalone with the most rings is found in observation 480, with a whole weight of 1.8075, a shucked weight of 0.7055, a viscera weight of 0.3215, and a shell weight of 0.475.

```{r}
abalones$Is.larger <- abalones$Viscera.weight > abalones$Shell.weight
count_larger <- sum(abalones$Is.larger)
(count_larger / nrow(abalones)) * 100
```

Approximately 6.51341% of abalones have a viscera weight larger than their shell weight.

#### d.

```{r}
weights <- c("Whole.weight", "Shucked.weight", "Viscera.weight", "Shell.weight")
abs_split <- split(abalones, abalones$Sex) #Splits into three separate data frames                                             by sex
cor_table <- sapply(abs_split, function(sub) {
  sapply(sub[weights], function(x) cor(x, sub$Rings))})
cor_table <- t(cor_table) #Makes rows the sexes
cor_table <- data.frame(Sex = rownames(cor_table), cor_table, row.names = NULL)
cor_table
```

#### e.

```{r}
#Testing for difference between male and female abalones
t.test(abalones$Rings[abalones$Sex == "M"], abalones$Rings[abalones$Sex == "F"])
```

```{r}
#Testing for difference between male and infant abalones
t.test(abalones$Rings[abalones$Sex == "M"], abalones$Rings[abalones$Sex == "I"])
```

```{r}
#Testing for difference between female and infant abalones
t.test(abalones$Rings[abalones$Sex == "F"], abalones$Rings[abalones$Sex == "I"])
```

The three t-tests show significant differences in mean number of rings across all sex groups, as their p-values all fall below any reasonable threshold.

### Problem 2

#### a.

```{r}
food_exp <- read.csv("data/food_expenditure.csv")
```

#### b.

```{r}
colnames(food_exp) <- c("ID",
                        "age",
                        "household_size",
                        "state",
                        "currency",
                        "total_expenditure",
                        "grocery_expenditure",
                        "dining_expenditure",
                        "misc_expenditure",
                        "times_dined",
                        "alcohol_included",
                        "assistance_programs")
```

#### c.

```{r}
food_usd <- food_exp[food_exp$currency == "USD", ]
cat("Before restriction: ", nrow(food_exp), " observations\n")
cat("After restriction: ", nrow(food_usd), " observations\n")
```

We can observe that the filtering was successful, as the new dataset contains 230 out of the original 262 observations.

#### d.

```{r}
food_exp <- food_exp[food_exp$age >= 18 & food_exp$age <= 100, ]
```

Excluded all minors as they are unlikely to be responsible for food spending, as well as implausible ages.

#### e.

```{r}
valid_states <- state.abb #Pre-made vector of all 50 U.S states
valid_states <- c(valid_states, "DC")
food_exp <- food_exp[food_exp$state %in% valid_states, ]
```

Removed invalid or missing entries for state name abbreviations (a.k.a anything that isn't one of the 50 U.S states plus Washington D.C)

#### f.

```{r}
food_exp <- food_exp[!is.na(food_exp$total_expenditure) & food_exp$total_expenditure >= 0, ]
food_exp <- food_exp[is.na(food_exp$grocery_expenditure) | (food_exp$grocery_expenditure >= 0), ]
food_exp <- food_exp[is.na(food_exp$dining_expenditure) | (food_exp$dining_expenditure >= 0), ]
food_exp <- food_exp[is.na(food_exp$misc_expenditure) | (food_exp$misc_expenditure >= 0), ]
```

Removed all instances of negative and missing values for total expenditure, but allowed NA to be a valid response for any of the subcategories/types of expenditures, as it is possible for those surveyed to have not spent any money in a particular area.

#### g.

```{r}
food_exp <- food_exp[
  (food_exp$times_dined > 0 & (is.na(food_exp$dining_expenditure) | food_exp$dining_expenditure >= 0)) |
  (food_exp$times_dined == 0 & (is.na(food_exp$dining_expenditure) | food_exp$dining_expenditure == 0)),
]
```

Removed any inconsistent/implausible responses between number of reported times dined out and dining expenditures (ex. cannot have possibly dined out 0 times but still spent \$13 on expenditures when dining out).

#### h.

```{r}
nrow(food_exp)
```

After filtering out observations based on the above criteria, the dataset has 173 remaining observations.

### Problem 3

#### a.

```{r}
#' Compute the next number in the Collatz sequence
#' 
#' @param n A positive number
#' @ return The next positive integer in the Collatz sequence
nextCollatz <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("Input must be a single positive integer")
  }
  
  if (n %% 2 == 0) {
    return(n / 2)
  } else {
    return(3 * n + 1)
  }
}
```

```{r}
nextCollatz(5)
```

```{r}
nextCollatz(16)
```

#### b.

```{r}
#' Compute the full Collatz sequence for a given integer
#' 
#' @param n A positive integer
#' @return A list containing:
#'            sequence: a vector of the Collatz sequence from n to 1
#'            length: the length of the above sequence
collatzSequence <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0 || n != floor(n)) {
    stop("Input must be a single positive integer")
  }
  
  seq_vec <- n
  while (seq_vec[length(seq_vec)] != 1) {
    seq_vec <- c(seq_vec, nextCollatz(seq_vec[length(seq_vec)]))
  }
  
  return(list(
    sequence = seq_vec,
    length = length(seq_vec)
  ))
}
```

```{r}
collatzSequence(5)
```

```{r}
collatzSequence(19)
```

#### c.

```{r}
values <- 100:500
seq_lengths <- sapply(values, function(x) collatzSequence(x)$length)
min_len <- min(seq_lengths)
shortest_start <- values[which(seq_lengths == min_len)[1]]  # lowest start in case of tie
max_len <- max(seq_lengths)
longest_start <- values[which(seq_lengths == max_len)[1]]  # lowest start in case of tie

cat("Shortest Collatz sequence starts at", shortest_start, "with length", min_len, "\n")
cat("Longest Collatz sequence starts at", longest_start, "with length", max_len, "\n")
```

### Resources Used:

R documentation for subset(), split(), and cat() functions, StackOverflow for nextCollatz function help, ChatGPT for debugging purposes
